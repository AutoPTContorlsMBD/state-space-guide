\section{Implementation steps} \label{sec:implementation-steps}

\subsection{Derive physical model}

A \gls{model} is a set of differential equations describing the system. Since
state-space representation requires that only single derivatives be used, they
should be broken up as separate states. For example, below is the \gls{model}
for a pendulum

\begin{equation}
  mL\ddot{x} = -mg \mathrm{sin}~x
\end{equation}

where $x$ is the angle of the pendulum.

\begin{equation*}
  \ddot{x} = -\frac{g}{L} \mathrm{sin}~x
\end{equation*}

\begin{align*}
  \dot{x}_1 &= x_2 \\
  \dot{x}_2 &= -\frac{g}{L} \mathrm{sin}~x_1
\end{align*}

where $x_1$ is $\theta$ and $x_2$ is $\dot{\theta}$. Since this \gls{model} is
nonlinear, we should linearize it. We will use the small angle approximation
($\mathrm{sin}~\theta = \theta$ for small values of $\theta$).

\begin{align*}
  \dot{x}_1 &= x_2 \\
  \dot{x}_2 &= -\frac{g}{L} x_1
\end{align*}

\subsection{Write model in state-space representation}

Continuing the example above:

\begin{align}
  \dot{\left[
  \begin{array}{c}
    x_1 \\
    x_2
  \end{array} \right]} = \left[
  \begin{array}{cc}
    0 & 1 \\
    -\frac{g}{L} & 0
  \end{array} \right] \left[
  \begin{array}{c}
    x_1 \\
    x_2
  \end{array} \right]
\end{align}

\subsection{Add estimator for unmeasured states}

The states may be a linear combination of measurements. After designing an
estimator, it can be used to supplement the inputs for a controller. \\

For example, we may only be measuring $\theta$ in the pendulum example, not
$\dot{\theta}$, so we'll need to estimate the latter.

\subsection{Implement controller}

Use Bryson's rule when making the performance vs actuation effort trade-off. For
the average system, optimizing actuation effort will get you to the reference in
the most efficient way possible, which can avoid voltage drops on robots with a
limited power supply.

\subsection{Simulate model/controller}

This can be done in any platform supporting numerical computation. Common
choices are MATLAB, v-REP, or Python. Tweak the LQR gain as necessary.

\subsection{Verify pole locations}

Check the pole locations as a sanity check and to potentially gain an intuition
for the chosen pole locations.

\subsection{Unit test}

Write unit tests to test the \gls{model} performance and \gls{robustness} under
different initial conditions and command inputs. If you are using C++, we
recommend Google Test.

\subsection{Test on real system}

Try the controller on a real \gls{system} with low maximum outputs for safety.
The outputs can be raised later.
