\chapterimage{nonlinear-control.jpg}{Trees by Interdisciplinary Sciences building at UCSC}

\chapter{Nonlinear control}
\label{ch:nonlinear_control}

While many tools exist for designing controllers for linear \glspl{system}, all
\glspl{system} in reality are inherently nonlinear. We'll briefly mention some
considerations for nonlinear \glspl{system}.

\section{Introduction}

Recall from linear \gls{system} theory that we defined \glspl{system} as having
the following form:

\begin{align*}
  \dot{\mtx{x}} &= \mtx{A}\mtx{x} + \mtx{B}\mtx{u} + \mtx{\Gamma}\mtx{w} \\
  \mtx{y} &= \mtx{C}\mtx{x} + \mtx{D}\mtx{u} + \mtx{v}
\end{align*}

In this equation, $\mtx{A}$ and $\mtx{B}$ are constant matrices. In nonlinear
\glspl{system}, the \gls{state} evolution and \gls{output} are defined by
arbitrary functions of the current \glspl{state} and \glspl{input}.

\begin{align*}
  \dot{\mtx{x}} &= f(\mtx{x}, \mtx{u}, \mtx{w}) \\
  \mtx{y} &= h(\mtx{x}, \mtx{u}, \mtx{v})
\end{align*}

\section{Linearization}
\index{Nonlinear control!linearization}

One way to control nonlinear \glspl{system} is to
\glslink{linearization}{linearize} the \gls{model} around a reference point.
Then, all the powerful tools that exist for linear controls can be applied. This
is done by taking the partial derivative of the functions.

\begin{align*}
  \begin{array}{cccc}
    \mtx{A} = \frac{\partial f(\mtx{x}, \mtx{0}, \mtx{0})}{\partial \mtx{x}} &
    \mtx{B} = \frac{\partial f(\mtx{0}, \mtx{u}, \mtx{0})}{\partial \mtx{u}} &
    \mtx{C} = \frac{\partial h(\mtx{x}, \mtx{0}, \mtx{0})}{\partial \mtx{x}} &
    \mtx{D} = \frac{\partial h(\mtx{0}, \mtx{u}, \mtx{0})}{\partial \mtx{u}}
  \end{array}
\end{align*}

Higher order partial derivatives can be added to better approximate the
nonlinear dynamics. We typically only \glslink{linearization}{linearize} around
equilibrium points because we are interested in how the \gls{system} behaves
when perturbed from equilibrium. An FAQ on this goes into more detail
\cite{bib:linearize_equilibrium_point}. To be clear though,
\glslink{linearization}{linearizing} the \gls{system} around the current
\gls{state} as the \gls{system} evolves does give a closer approximation over
time.

\section{Nonlinear observers}

In this book, we have covered the Kalman filter, which is the optimal unbiased
estimator for linear \glspl{system}. It isn't optimal for nonlinear
\glspl{system}, but several extensions to it have been developed to make it more
accurate.

\subsection{Extended Kalman filter}
\index{Nonlinear control!extended Kalman filter}
\index{State-space observers!Kalman filter!extended Kalman filter}

This method \glslink{linearization}{linearizes} the matrices used during the
prediction step. In addition to the $\mtx{A}$, $\mtx{B}$, $\mtx{C}$, and
$\mtx{D}$ matrices above, the process noise intensity vector $\mtx{\Gamma}$ is
\glslink{linearization}{linearized} as follows:

\begin{equation*}
  \mtx{\Gamma} = \frac{\partial f(\mtx{x}, \mtx{0}, \mtx{0})}{\partial \mtx{w}}
\end{equation*}

where $\mtx{w}$ is the process noise included in the stochastic model.

From there, the continuous Kalman filter equations are used like normal to
compute the error covariance matrix $\mtx{P}$ and Kalman gain matrix. The
\gls{state} estimate update can still use the function $h(\mtx{x})$ for
accuracy.

\begin{equation*}
  \hat{\mtx{x}}_{k+1}^+ = \hat{\mtx{x}}_{k+1}^- +
    \mtx{K}_{k+1}(\mtx{y}_{k+1} - h(\hat{\mtx{x}}_{k+1}^-))
\end{equation*}

\subsection{Unscented Kalman filter}
\index{Nonlinear control!unscented Kalman filter}
\index{State-space observers!Kalman filter!unscented Kalman filter}

This method \glslink{linearization}{linearizes} around carefully chosen points
to minimize the modeling error. There's a lot of detail to cover, so we
recommend just reading a paper on it \cite{bib:unscented_kalman_filter}.

Here's a paper on a quaternion-based Unscented Kalman filter for orientation
tracking \cite{bib:ukf_state_tracking}.

\section{Lyapunov stability}
\index{Nonlinear control!Lyapunov stability}

Lyapunov stability is a fundamental concept in nonlinear control, so we're going
to give a brief overview of what it is so students can research it further.

Since the \gls{state} evolution in nonlinear \glspl{system} is defined by a
function rather than a constant matrix, the \gls{system}'s poles as determined
by \gls{linearization} move around. Nonlinear control uses Lyapunov stability to
determine if nonlinear \glspl{system} are stable. From a linear control theory
point of view, Lyapunov stability says the \gls{system} is stable if, for a
given initial condition, all possible eigenvalues of $\mtx{A}$ from that point
on remain in the left-half plane. However, nonlinear control uses a different
definition.

Essentially, Lyapunov stability means that the \gls{system} trajectory can be
kept arbitrarily close to the origin by starting sufficiently close to it.
Lyapunov's direct method is concerned with finding a function representing the
energy in a \gls{system} to prove that the \gls{system} is stable around an
equilibrium point. This can be used to prove a \gls{system}'s open-loop
stability as well as its closed-loop stability in the presence of a controller.
Typically, these functions include the energy of the \gls{system} or the
derivatives of the \gls{system} \gls{state}, which are then used to show the
\gls{system} decays to some ground state.

Lyapunov functions are merely sufficient to prove stability (as opposed to a
specific Lyapunov function being necessary). If one function doesn't prove it,
another candidate should be tried. For this reason, we refer to these functions
as \textit{Lyapunov candidate functions}.

\section{Nonlinear control law for wheeled vehicle}

\subsection{Unicycle-like vehicle}

The paper \textit{Control of Wheeled Mobile Robots: An Experimental Overview}
describes a nonlinear controller for a wheeled vehicle with unicycle-like
kinematics and a global \gls{pose} consisting of $x$, $y$, and $\theta$
\cite{bib:ctrl_wheeled_mobile_robots}. They use the following Lyapunov function.

\begin{equation*}
  V = \frac{\overline{k}_2}{2}(e_1^2 + e_2^2) + \frac{e_3^2}{2}
\end{equation*}

where $\overline{k}_2$ is a tuning constant, $e_1$ is the tracking error in $x$,
$e_2$ is the tracking error in $y$, and $e_3$ is the tracking error in $\theta$.

The time derivative along the solutions of the closed-loop \gls{system} is
nonincreasing since

\begin{equation*}
  \dot{V} = -k_1 \overline{k}_2 e_1^2 - k_3 e_3^2 \leq 0
\end{equation*}

Thus, $\lVert e(t) \rVert$ is bounded, $\dot{V}(t)$ is uniformly continuous,
and $V(t)$ tends to some limit value. Using the Barbalat lemma, $\dot{V}(t)$
tends to zero \cite{bib:ctrl_wheeled_mobile_robots}.

The commanded velocity $v$ and turning rate $\omega$ are

\begin{align}
  v =~& v_d \cos(\theta_d - \theta) + k_1(v_d, \omega_d)(\cos\theta(x_d - x) +
    \sin\theta(y_d - y)) \\
  \omega =~& \omega_d +
    \overline{k}_2 v_d\frac{\sin(\theta_d - \theta)}{\theta_d - \theta}
    (\cos\theta(x_d - x) - \sin\theta(y_d - y)) + \nonumber \\
    &k_3 (v_d, \omega_d)(\theta_d - \theta) \\
  k_1(v_d(t), \omega_d(t)) =~& k_3(v_d(t), \omega_d(t)) =
    2\zeta\sqrt{\omega_d^2(t) + bv_d^2(t)}
\end{align}

where $v_d$ is the desired velocity, $x_d$ is the desired $x$ position, $y_d$ is
the desired $y$ position, and $\overline{k}_2 = b$ with $b > 0$ and
$\zeta \in (0, 1)$.

$v$ and $\omega$ should be the \glspl{reference} for a \gls{reference} tracker
for the drivetrain. This can be a linear controller.

$x$, $y$, and $\theta$ are obtained via a nonlinear \gls{pose} estimator. The
simplest way to do this is by integrating the velocity in each orthogonal
direction over time using

\begin{align*}
  x_{k+1} = x_k + v_k\cos\theta_k\,T \\
  y_{k+1} = y_k + v_k\sin\theta_k\,T
\end{align*}

where $T$ is the sample period. $x_d$, $y_d$, and $\theta_d$ are obtained from a
desired time-based trajectory.

\subsection{Two-wheeled vehicle}

The mapping from $v$ and $\omega$ to the left and right wheel velocities $v_L$
and $v_R$ are derived as follows. Let $\vec{v}_C$ be the velocity vector of the
center of rotation, $\vec{v}_L$ be the velocity vector of the left wheel,
$\vec{v}_R$ be the velocity vector of the right wheel, $r_b$ is the distance
from the center of rotation to each wheel, and $\omega$ is the counterclockwise
turning rate around the center of rotation. For this derivation, we'll assume
the robot is facing in the $\hat{j}$ direction.

The main equation we'll need is the following.

\begin{equation*}
  \vec{v}_B = \vec{v}_A + \omega_A \times \vec{r}_{B|A}
\end{equation*}

where $\vec{v}_B$ is the velocity vector at point B, $\vec{v}_A$ is the velocity
vector at point A, $\omega_A$ is the angular velocity vector at point A, and
$\vec{r}_{B|A}$ is the distance vector from point A to point B (also described
as the ``distance to B relative to A").

First, we'll derive $v_L$.

\begin{align}
  \vec{v}_L &= v_C \hat{j} + \omega \hat{k} \times -r_b \hat{i} \nonumber
    \\
  \vec{v}_L &= v_C \hat{j} - \omega r_b \hat{j} \nonumber \\
  \vec{v}_L &= (v_C - \omega r_b) \hat{j} \nonumber \\
  \lvert\vec{v}_L\rvert &= v_C - \omega r_b \nonumber \\
  v_L &= v_C - \omega r_b
\end{align}

Next, we'll derive $v_R$.

\begin{align}
  \vec{v}_R &= v_C \hat{j} + \omega \hat{k} \times r_b \hat{i} \nonumber
    \\
  \vec{v}_R &= v_C \hat{j} + \omega r_b \hat{j} \nonumber \\
  \vec{v}_R &= (v_C + \omega r_b) \hat{j} \nonumber \\
  \lvert\vec{v}_R\rvert &= v_C + \omega r_b \nonumber \\
  v_R &= v_C + \omega r_b
\end{align}

\subsubsection{Linear reference tracker}

We'll need a velocity \gls{reference} tracker for the nonlinear
\gls{controller}'s commands. Given equation (\ref{eq:drivetrain_ss_model})

\begin{equation*}
  \begin{array}{ccc}
    \mtx{x} =
    \begin{bmatrix}
      x_l \\
      v_l \\
      x_r \\
      v_r
    \end{bmatrix} &
    \mtx{y} =
    \begin{bmatrix}
      x_l \\
      x_r
    \end{bmatrix} &
    \mtx{u} =
    \begin{bmatrix}
      V_l \\
      V_r
    \end{bmatrix}
  \end{array}
\end{equation*}

\begin{equation*}
  \begin{array}{ll}
    \mtx{A} =
    \begin{bmatrix}
      0 & 1 & 0 & 0 \\
      0 & \left(\frac{1}{m} + \frac{r_b^2}{J}\right) C_1 & 0 & \left(\frac{1}{m} - \frac{r_b^2}{J}\right) C_3 \\
      0 & 0 & 0 & 1 \\
      0 & \left(\frac{1}{m} - \frac{r_b^2}{J}\right) C_1 & 0 & \left(\frac{1}{m} + \frac{r_b^2}{J}\right) C_3
    \end{bmatrix} &
    \mtx{B} =
    \begin{bmatrix}
      0 & 0 \\
      \left(\frac{1}{m} + \frac{r_b^2}{J}\right) C_2 & \left(\frac{1}{m} - \frac{r_b^2}{J}\right) C_4 \\
      0 & 0 \\
      \left(\frac{1}{m} - \frac{r_b^2}{J}\right) C_2 & \left(\frac{1}{m} + \frac{r_b^2}{J}\right) C_4
    \end{bmatrix} \\
    \mtx{C} =
    \begin{bmatrix}
      1 & 0 & 0 & 0 \\
      0 & 0 & 1 & 0 \\
    \end{bmatrix} &
    \mtx{D} = \mtx{0}_{2 \times 2}
  \end{array}
\end{equation*}

where $C_1 = -\frac{G_l^2 K_t}{K_v R r^2}$, $C_2 = \frac{G_l K_t}{Rr}$,
$C_3 = -\frac{G_r^2 K_t}{K_v R r^2}$, and $C_4 = \frac{G_r K_t}{Rr}$.

We can obtain a velocity \gls{reference} tracker by just removing the position
\glspl{state} from the \gls{model}.

\begin{equation*}
  \begin{array}{ccc}
    \mtx{x} =
    \begin{bmatrix}
      v_l \\
      v_r
    \end{bmatrix} &
    \mtx{y} =
    \begin{bmatrix}
      v_l \\
      v_r
    \end{bmatrix} &
    \mtx{u} =
    \begin{bmatrix}
      V_l \\
      V_r
    \end{bmatrix}
  \end{array}
\end{equation*}

\begin{equation}
  \begin{array}{ll}
    \mtx{A} =
    \begin{bmatrix}
      \left(\frac{1}{m} + \frac{r_b^2}{J}\right) C_1 & \left(\frac{1}{m} - \frac{r_b^2}{J}\right) C_3 \\
      \left(\frac{1}{m} - \frac{r_b^2}{J}\right) C_1 & \left(\frac{1}{m} + \frac{r_b^2}{J}\right) C_3
    \end{bmatrix} &
    \mtx{B} =
    \begin{bmatrix}
      \left(\frac{1}{m} + \frac{r_b^2}{J}\right) C_2 & \left(\frac{1}{m} - \frac{r_b^2}{J}\right) C_4 \\
      \left(\frac{1}{m} - \frac{r_b^2}{J}\right) C_2 & \left(\frac{1}{m} + \frac{r_b^2}{J}\right) C_4
    \end{bmatrix} \\
    \mtx{C} =
    \begin{bmatrix}
      1 & 0 \\
      0 & 1 \\
    \end{bmatrix} &
    \mtx{D} = \mtx{0}_{2 \times 2}
  \end{array}
\end{equation}

\section{Further reading}

For learning more about nonlinear control, we recommend reading the book
\textit{Applied Nonlinear Control} by Jean-Jacques Slotine. For a more complex
type of nonlinear control, read \textit{A guiding vector field algorithm for
path following control of nonholonomic mobile robots} \cite{bib:gvf}.
