\section{Elevator}

\subsection{Equations of motion}

This elevator consists of a DC brushed motor attached to a pulley that drives a
mass up or down.

\begin{bookfigure}
  \begin{tikzpicture}[auto, >=latex', circuit ee IEC,
                      set resistor graphic=var resistor IEC graphic]
    % \draw [help lines] (-1,-3) grid (7,4);

    % Electrical equivalent circuit
    \draw (0,2) to [voltage source={direction info'={->}, info'=$V$}] (0,0);
    \draw (0,2) to [current direction={info=$I$}] (0,3);
    \draw (0,3) -- (0.5,3);
    \draw (0.5,3) to [resistor={info={$R$}}] (2,3);

    \draw (2,3) -- (2.5,3);
    \draw (2.5,3) to [voltage source={direction info'={->}, info'=$V_{emf}$}]
      (2.5,0);
    \draw (0,0) -- (2.5,0);

    % Motor
    \begin{scope}[xshift=2.4cm,yshift=1.05cm]
      \draw[fill=black] (0,0) rectangle (0.2,0.9);
      \draw[fill=white] (0.1,0.45) ellipse (0.3 and 0.3);
    \end{scope}

    % Transmission gear one
    \begin{scope}[xshift=3.75cm,yshift=1.17cm]
      \draw[fill=black!50] (0.2,0.33) ellipse (0.08 and 0.33);
      \draw[fill=black!50, color=black!50] (0,0) rectangle (0.2,0.66);
      \draw[fill=white] (0,0.33) ellipse (0.08 and 0.33);
      \draw (0,0.66) -- (0.2,0.66);
      \draw (0,0) -- (0.2,0) node[pos=0.5,below] {$G$};
    \end{scope}

    % Output shaft of motor
    \begin{scope}[xshift=2.8cm,yshift=1.45cm]
      \draw[fill=black!50] (0,0) rectangle (0.95,0.1);
    \end{scope}

    % Angular velocity arrow of drive -> transmission
    \draw[line width=0.7pt,<-] (3.2,1) arc (-30:30:1) node[above] {$\omega_m$};

    % Transmission gear two
    \begin{scope}[xshift=3.75cm,yshift=1.83cm]
      \draw[fill=black!50] (0.2,0.68) ellipse (0.13 and 0.67);
      \draw[fill=black!50, color=black!50] (0,0) rectangle (0.2,1.35);
      \draw[fill=white] (0,0.68) ellipse (0.13 and 0.67);
      \draw (0,1.35) -- (0.2,1.35);
      \draw (0,0) -- (0.2,0);
    \end{scope}

    % Pulley rear chain
    \begin{scope}[xshift=5.03cm,yshift=0.32cm]
      \draw[fill=black!70, color=black!70] (0.01,2.17) rectangle (0.09,0);
      \draw (0,2.17) -- (0,0);
      \draw (0.1,2.17) -- (0.1,0);
    \end{scope}

    % Upper pulley
    \begin{scope}[xshift=5.05cm,yshift=2.09cm]
      \draw[fill=black!50] (0.2,0.4) ellipse (0.13 and 0.4);
      \draw[fill=black!70] (0.15,0.4) ellipse (0.13 and 0.4);
      \draw[fill=black!50, color=black!50] (0,0) rectangle (0.1,0.8);
      \draw[fill=black!70, color=black!70] (0.1,0) rectangle (0.15,0.8);
      \draw[fill=black!50] (0.05,0.4) ellipse (0.13 and 0.4);
      \draw[fill=black!50, color=black!50] (0,0) rectangle (0.05,0.8);
      \draw[fill=white] (0,0.4) ellipse (0.13 and 0.4);
      \draw (0,0) -- (0.2,0);
      \draw (0,0.8) -- (0.2,0.8);
    \end{scope}

    % Lower pulley
    \begin{scope}[xshift=5.05cm,yshift=-0.05cm]
      \draw[fill=black!50] (0.2,0.4) ellipse (0.13 and 0.4);
      \draw[fill=black!70] (0.15,0.4) ellipse (0.13 and 0.4);
      \draw[fill=black!50, color=black!50] (0,0) rectangle (0.1,0.8);
      \draw[fill=black!70, color=black!70] (0.1,0) rectangle (0.15,0.8);
      \draw[fill=black!50] (0.05,0.4) ellipse (0.13 and 0.4);
      \draw[fill=black!50, color=black!50] (0,0) rectangle (0.05,0.8);
      \draw[fill=white] (0,0.4) ellipse (0.13 and 0.4);
      \draw (0,0) -- (0.2,0);
      \draw (0,0.8) -- (0.2,0.8);
    \end{scope}

    % Transmission shaft from gear two to pulley
    \begin{scope}[xshift=4.09cm,yshift=2.42cm]
      \draw[fill=black!50] (0,0) rectangle (0.96,0.1);
    \end{scope}

    % Angular velocity arrow between transmission and pulley
    \draw[line width=0.7pt,->] (4.54,1.97) arc (-30:30:1) node[above]
      {$\omega_p$};

    % Pulley front chain
    \begin{scope}[xshift=5.23cm,yshift=0.32cm]
      \draw[fill=black!70, color=black!70] (0.01,2.17) rectangle (0.09,0);
      \draw (0,2.17) -- (0,0);
      \draw (0.1,2.17) -- (0.1,0);
    \end{scope}

    % Pulley radius arrow
    \begin{scope}[xshift=5.54cm,yshift=2.49]
      \draw[line width=0.7pt,<->] (0,-0.15) -- node[right] {$r$} (0,0.35);
    \end{scope}

    % Mass
    \begin{scope}[xshift=4.89cm,yshift=0.82cm]
      \fill[fill=white] (0,0.8) -- (0,0.2) -- (0.2,0) -- (0.2,0.2)
        -- (0.98,0.2) -- (0.78,0.8) -- cycle;
      \draw (0,0.8) -- (0.78,0.8);
      \draw (0,0.8) -- (0,0.2);
      \draw (0,0.2) -- (0.2,0);
      \draw (0,0.8) -- (0.2,0.6);
      \draw (0.78,0.8) -- (0.98,0.6);
      \draw[fill=white] (0.2,0.6) rectangle (0.98,0);
    \end{scope}

    % Mass velocity arrow
    \begin{scope}[xshift=6.04cm,yshift=0.95cm]
      \draw[line width=0.7pt,<-] (0,0.4) -- node {$v_m$} (0,0);
    \end{scope}

    % Descriptions inside graphic
    \draw (5.48,1.12) node {$m$};

    % Descriptions of subsystems under graphic
    \begin{scope}[xshift=-0.5cm,yshift=-0.28cm]
      \draw[decorate,decoration={brace,amplitude=10pt}]
        (3.5,0) -- (0,0) node[midway,yshift=-20pt] {circuit};
      \draw[decorate,decoration={brace,amplitude=10pt}]
        (7.05,0) -- (3.75,0) node[midway,yshift=-20pt] {mechanics};
    \end{scope}
  \end{tikzpicture}

  \caption{Elevator system diagram}
  \label{fig:elevator}
\end{bookfigure}

Gear ratios are written as output over input, so $G$ is greater than one in
figure \ref{fig:elevator}.

Based on figure \ref{fig:elevator}

\begin{equation}
  \tau_m G = \tau_p \label{eq:elevator_tau_m_ratio}
\end{equation}

where $G$ is the gear ratio between the motor and the pulley and $\tau_p$ is the
torque produced by the pulley.

\begin{equation}
  rF_m = \tau_p \label{eq:elevator_torque_pulley}
\end{equation}

where $r$ is the radius of the pulley. Substitute equation
(\ref{eq:elevator_tau_m_ratio}) into equation (\ref{eq:motor_tau_V}).

\begin{align*}
  V &= \frac{\frac{\tau_p}{G}}{K_t} R + \frac{\omega_m}{K_v} \\
  V &= \frac{\tau_p}{GK_t} R + \frac{\omega_m}{K_v}
\end{align*}

Substitute in equation (\ref{eq:elevator_torque_pulley}).

\begin{equation}
  V = \frac{rF_m}{GK_t} R + \frac{\omega_m}{K_v} \label{eq:elevator_Vinter1}
\end{equation}

The angular velocity of the motor armature $\omega_m$ is

\begin{equation}
  \omega_m = G \omega_p \label{eq:elevator_omega_m_ratio}
\end{equation}

where $\omega_p$ is the angular velocity of the pulley. The velocity of the mass
(the elevator carriage) is

\begin{equation*}
  v_m = r \omega_p
\end{equation*}

\begin{equation}
  \omega_p = \frac{v_m}{r} \label{eq:elevator_omega_p}
\end{equation}

Substitute equation (\ref{eq:elevator_omega_p}) into equation
(\ref{eq:elevator_omega_m_ratio}).

\begin{equation}
  \omega_m = G \frac{v_m}{r} \label{eq:elevator_omega_m}
\end{equation}

Substitute equation (\ref{eq:elevator_omega_m}) into equation
(\ref{eq:elevator_Vinter1}).

\begin{align*}
  V &= \frac{rF_m}{GK_t} R + \frac{G \frac{v_m}{r}}{K_v} \\
  V &= \frac{RrF_m}{GK_t} + \frac{G}{rK_v} v_m
\end{align*}

Solve for $F_m$.

\begin{align}
  \frac{RrF_m}{GK_t} &= V - \frac{G}{rK_v} v_m \nonumber \\
  F_m &= \left(V - \frac{G}{rK_v} v_m\right) \frac{GK_t}{Rr} \nonumber \\
  F_m &= \frac{GK_t}{Rr} V - \frac{G^2K_t}{Rr^2 K_v} v_m \label{eq:elevator_F_m}
\end{align}

\begin{equation}
  \sum F = ma_m \label{eq:elevator_F_ma}
\end{equation}

where $\sum F$ is the sum of forces applied to the elevator carriage, $m$ is the
mass of the elevator carriage in kilograms, and $a_m$ is the acceleration of the
elevator carriage.

\begin{equation*}
  ma_m = F_m
\end{equation*}

\begin{remark}
  Gravity is not part of the modeled dynamics because it complicates the
  state-space \gls{model} and the controller will behave well enough without it.
\end{remark}

\begin{align}
  ma_m &= \left(\frac{GK_t}{Rr} V - \frac{G^2K_t}{Rr^2 K_v} v_m\right)
    \nonumber \\
  a_m &= \frac{GK_t}{Rrm} V - \frac{G^2K_t}{Rr^2 mK_v} v_m
    \label{eq:elevator_accel}
\end{align}

\subsection{Continuous state-space model}
\index{FRC models!elevator equations}

The position and velocity of the elevator can be written as

\begin{align}
  \dot{x}_m &= v_m \label{eq:elevator_cont_ss_pos} \\
  \dot{v}_m &= a_m \label{eq:elevator_cont_ss_vel}
\end{align}

where by equation (\ref{eq:elevator_accel}),

\begin{equation*}
  a_m = \frac{GK_t}{Rrm} V - \frac{G^2 K_t}{Rr^2 m K_v} v_m
\end{equation*}

Substitute this into equation (\ref{eq:elevator_cont_ss_vel}).

\begin{align}
  \dot{v}_m &= \frac{GK_t}{Rrm} V - \frac{G^2 K_t}{Rr^2 m K_v} v_m \nonumber \\
  \dot{v}_m &= -\frac{G^2 K_t}{Rr^2 m K_v} v_m + \frac{GK_t}{Rrm} V
\end{align}

\begin{theorem}[Elevator state-space model]
  \begin{align*}
    \dot{\mtx{x}} &= \mtx{A} \mtx{x} + \mtx{B} \mtx{u} \\
    \mtx{y} &= \mtx{C} \mtx{x} + \mtx{D} \mtx{u}
  \end{align*}
  \begin{equation*}
    \begin{array}{ccc}
      \mtx{x} =
      \begin{bmatrix}
        x \\
        v_m
      \end{bmatrix} &
      \mtx{y} = x &
      \mtx{u} = V
    \end{array}
  \end{equation*}
  \begin{equation}
    \begin{array}{cccc}
      \mtx{A} =
      \begin{bmatrix}
        0 & 1 \\
        0 & -\frac{G^2 K_t}{Rr^2 mK_v}
      \end{bmatrix} &
      \mtx{B} =
      \begin{bmatrix}
        0 \\
        \frac{GK_t}{Rrm}
      \end{bmatrix} &
      \mtx{C} =
      \begin{bmatrix}
        1 & 0
      \end{bmatrix} &
      \mtx{D} = 0
    \end{array}
  \end{equation}
\end{theorem}

\subsection{Model augmentation}

As per subsection \ref{subsec:u_error_estimation}, we will now augment the
\gls{model} so a $u_{error}$ term is added to the \gls{control input}.

The \gls{plant} and \gls{observer} augmentations should be performed before the
\gls{model} is \glslink{discretization}{discretized}. After the \gls{controller}
gain is computed with the unaugmented discrete \gls{model}, the controller may
be augmented. Therefore, the \gls{plant} and \gls{observer} augmentations assume
a continuous \gls{model} and the \gls{controller} augmentation assumes a
discrete \gls{controller}.

\begin{equation*}
  \begin{array}{ccc}
    \mtx{x}_{aug} =
    \begin{bmatrix}
      x \\
      v_m \\
      u_{error}
    \end{bmatrix} &
    \mtx{y} = x &
    \mtx{u} = V
  \end{array}
\end{equation*}

\begin{equation}
  \begin{array}{cccc}
    \mtx{A}_{aug} =
    \begin{bmatrix}
      \mtx{A} & \mtx{B} \\
      \mtx{0}_{1 \times 2} & 0
    \end{bmatrix} &
    \mtx{B}_{aug} =
    \begin{bmatrix}
      \mtx{B} \\
      0
    \end{bmatrix} &
    \mtx{C}_{aug} = \begin{bmatrix}
      \mtx{C} & 0
    \end{bmatrix} &
    \mtx{D}_{aug} = \mtx{D}
  \end{array}
\end{equation}

\begin{equation}
  \begin{array}{cc}
    \mtx{K}_{aug} = \begin{bmatrix}
      \mtx{K} & 1
    \end{bmatrix} &
    \mtx{r}_{aug} = \begin{bmatrix}
      \mtx{r} \\
      0
    \end{bmatrix}
  \end{array}
\end{equation}

This will compensate for unmodeled dynamics such as gravity. However, using a
constant feedforward to counteract gravity is preferred over this method.

\subsection{Simulation}

Python Control will be used to \glslink{discretization}{discretize} the
\gls{model} and simulate it. One of the frccontrol
examples\footnote{\url{https://github.com/calcmogul/frccontrol/blob/master/examples/elevator.py}}
creates and tests a controller for it.

Figure \ref{fig:elevator_pzmaps} shows the pole-zero maps for the open-loop
\gls{system}, closed-loop \gls{system}, and \gls{observer}. Figure
\ref{fig:elevator_response} shows the \gls{system} response with them.

\begin{svg}{build/elevator_pzmaps}
  \caption{Elevator pole-zero maps}
  \label{fig:elevator_pzmaps}
\end{svg}

\begin{svg}{build/elevator_response}
  \caption{Elevator response}
  \label{fig:elevator_response}
\end{svg}

\subsection{Implementation}

The script linked above also generates two files: ElevatorCoeffs.h and
ElevatorCoeffs.cpp. These can be used with the WPILib StateSpacePlant,
StateSpaceController, and StateSpaceObserver classes in C++ and Java. A C++
implementation of this elevator controller is available online\footnote{
\url{https://github.com/calcmogul/allwpilib/tree/state-space/wpilibcExamples/src/main/cpp/examples/StateSpaceElevator}}.

\begin{remark}
  Instead of implementing $u_{error}$ estimation to compensate for gravity, one
  can apply a constant voltage feedforward since input voltage is proportional
  to force and gravity is a constant force.
\end{remark}
